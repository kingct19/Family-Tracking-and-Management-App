{"version":3,"file":"xp-api-Dlw9aMIE.js","sources":["../../src/features/xp/api/xp-api.ts"],"sourcesContent":["import { collection, addDoc, query, where, getDocs, orderBy, limit, Timestamp } from 'firebase/firestore';\nimport { db } from '@/config/firebase';\nimport type { ApiResponse } from '@/types';\n\nexport interface XPRecord {\n    id: string;\n    userId: string;\n    userName: string;\n    amount: number;\n    source: 'task_completion' | 'photo_approval' | 'streak_bonus' | 'achievement' | 'manual';\n    sourceId?: string;\n    description: string;\n    timestamp: Date;\n    hubId?: string;\n}\n\ninterface AwardXPData {\n    userId: string;\n    userName: string;\n    amount: number;\n    source: XPRecord['source'];\n    sourceId?: string;\n    description: string;\n    hubId?: string;\n}\n\n/**\n * Award XP to a user\n */\nexport const awardXP = async (data: AwardXPData): Promise<ApiResponse<XPRecord>> => {\n    try {\n        const xpData = {\n            userId: data.userId,\n            userName: data.userName,\n            amount: data.amount,\n            source: data.source,\n            sourceId: data.sourceId || null,\n            description: data.description,\n            timestamp: Timestamp.now(),\n            hubId: data.hubId || null,\n        };\n\n        const docRef = await addDoc(collection(db, 'xpRecords'), xpData);\n\n        const record: XPRecord = {\n            id: docRef.id,\n            ...data,\n            timestamp: new Date(),\n        };\n\n        return {\n            success: true,\n            data: record,\n        };\n    } catch (error) {\n        console.error('Award XP error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to award XP',\n        };\n    }\n};\n\n/**\n * Get XP records for a user\n */\nexport const getUserXPRecords = async (\n    userId: string,\n    limitCount: number = 50\n): Promise<ApiResponse<XPRecord[]>> => {\n    try {\n        const q = query(\n            collection(db, 'xpRecords'),\n            where('userId', '==', userId),\n            orderBy('timestamp', 'desc'),\n            limit(limitCount)\n        );\n\n        const snapshot = await getDocs(q);\n        const records: XPRecord[] = [];\n\n        snapshot.forEach((doc) => {\n            const data = doc.data();\n            records.push({\n                id: doc.id,\n                userId: data.userId,\n                userName: data.userName,\n                amount: data.amount,\n                source: data.source,\n                sourceId: data.sourceId,\n                description: data.description,\n                timestamp: data.timestamp?.toDate() || new Date(),\n                hubId: data.hubId,\n            });\n        });\n\n        return {\n            success: true,\n            data: records,\n        };\n    } catch (error) {\n        console.error('Get user XP records error:', error);\n        return {\n            success: true,\n            data: [],\n        };\n    }\n};\n\n/**\n * Calculate user's current streak\n */\nexport const calculateStreak = async (userId: string): Promise<ApiResponse<number>> => {\n    try {\n        const records = await getUserXPRecords(userId, 100);\n        \n        if (!records.success || !records.data || records.data.length === 0) {\n            return { success: true, data: 0 };\n        }\n\n        let streak = 0;\n        const today = new Date();\n        today.setHours(0, 0, 0, 0);\n\n        // Check if user earned XP today\n        const todayRecords = records.data.filter((record: XPRecord) => {\n            const recordDate = new Date(record.timestamp);\n            recordDate.setHours(0, 0, 0, 0);\n            return recordDate.getTime() === today.getTime();\n        });\n\n        if (todayRecords.length === 0) {\n            return { success: true, data: 0 };\n        }\n\n        // Count consecutive days\n        streak = 1;\n        let currentDate = new Date(today);\n        currentDate.setDate(currentDate.getDate() - 1);\n\n        for (let i = 0; i < 365; i++) {\n            const dayRecords = records.data.filter((record: XPRecord) => {\n                const recordDate = new Date(record.timestamp);\n                recordDate.setHours(0, 0, 0, 0);\n                return recordDate.getTime() === currentDate.getTime();\n            });\n\n            if (dayRecords.length > 0) {\n                streak++;\n                currentDate.setDate(currentDate.getDate() - 1);\n            } else {\n                break;\n            }\n        }\n\n        return {\n            success: true,\n            data: streak,\n        };\n    } catch (error) {\n        console.error('Calculate streak error:', error);\n        return {\n            success: true,\n            data: 0,\n        };\n    }\n};\n\n/**\n * Get leaderboard for a hub\n */\nexport const getLeaderboard = async (\n    hubId?: string,\n    limitCount: number = 10\n): Promise<ApiResponse<Array<{ userId: string; userName: string; totalXP: number; rank: number }>>> => {\n    try {\n        const q = hubId\n            ? query(\n                  collection(db, 'xpRecords'),\n                  where('hubId', '==', hubId),\n                  orderBy('timestamp', 'desc')\n              )\n            : query(collection(db, 'xpRecords'), orderBy('timestamp', 'desc'));\n\n        const snapshot = await getDocs(q);\n        const userXP: Record<string, { userName: string; totalXP: number }> = {};\n\n        snapshot.forEach((doc) => {\n            const data = doc.data();\n            if (!userXP[data.userId]) {\n                userXP[data.userId] = {\n                    userName: data.userName,\n                    totalXP: 0,\n                };\n            }\n            userXP[data.userId].totalXP += data.amount;\n        });\n\n        const leaderboard = Object.entries(userXP)\n            .map(([userId, data]) => ({\n                userId,\n                userName: data.userName,\n                totalXP: data.totalXP,\n                photoURL: (data as any).photoURL,\n                rank: 0,\n            }))\n            .sort((a, b) => b.totalXP - a.totalXP)\n            .slice(0, limitCount)\n            .map((entry, index) => ({\n                ...entry,\n                rank: index + 1,\n            }));\n\n        return {\n            success: true,\n            data: leaderboard,\n        };\n    } catch (error) {\n        console.error('Get leaderboard error:', error);\n        return {\n            success: true,\n            data: [],\n        };\n    }\n};\n\n/**\n * Get user's rank in the leaderboard\n */\nexport const getUserRank = async (userId: string, hubId?: string): Promise<ApiResponse<number>> => {\n    try {\n        const leaderboardResponse = await getLeaderboard(hubId, 1000);\n        \n        if (!leaderboardResponse.success || !leaderboardResponse.data) {\n            return { success: true, data: 0 };\n        }\n\n        const userEntry = leaderboardResponse.data.find((entry) => entry.userId === userId);\n        \n        return {\n            success: true,\n            data: userEntry?.rank || 0,\n        };\n    } catch (error) {\n        console.error('Get user rank error:', error);\n        return {\n            success: true,\n            data: 0,\n        };\n    }\n};\n\n"],"names":["awardXP","async","data","xpData","userId","userName","amount","source","sourceId","description","timestamp","Timestamp","now","hubId","docRef","addDoc","collection","db","success","id","Date","error","console","Error","message","getLeaderboard","limitCount","q","query","where","orderBy","snapshot","getDocs","userXP","forEach","doc","totalXP","Object","entries","map","photoURL","rank","sort","a","b","slice","entry","index"],"mappings":"6HA6BO,MAAMA,EAAUC,MAAOC,IAC1B,IACI,MAAMC,EAAS,CACXC,OAAQF,EAAKE,OACbC,SAAUH,EAAKG,SACfC,OAAQJ,EAAKI,OACbC,OAAQL,EAAKK,OACbC,SAAUN,EAAKM,UAAY,KAC3BC,YAAaP,EAAKO,YAClBC,UAAWC,EAAUC,MACrBC,MAAOX,EAAKW,OAAS,MAGnBC,QAAeC,EAAOC,EAAWC,EAAI,aAAcd,GAQzD,MAAO,CACHe,SAAS,EACThB,KARqB,CACrBiB,GAAIL,EAAOK,MACRjB,EACHQ,cAAeU,MAOvB,OAASC,GAEL,OADAC,QAAQD,MAAM,kBAAmBA,GAC1B,CACHH,SAAS,EACTG,MAAOA,aAAiBE,MAAQF,EAAMG,QAAU,qBAExD,GA+GSC,EAAiBxB,MAC1BY,EACAa,EAAqB,MAErB,IACI,MAAMC,EAAId,EACJe,EACIZ,EAAWC,EAAI,aACfY,EAAM,QAAS,KAAMhB,GACrBiB,EAAQ,YAAa,SAEzBF,EAAMZ,EAAWC,EAAI,aAAca,EAAQ,YAAa,SAExDC,QAAiBC,EAAQL,GACzBM,EAAgE,CAAA,EAEtEF,EAASG,QAASC,IACd,MAAMjC,EAAOiC,EAAIjC,OACZ+B,EAAO/B,EAAKE,UACb6B,EAAO/B,EAAKE,QAAU,CAClBC,SAAUH,EAAKG,SACf+B,QAAS,IAGjBH,EAAO/B,EAAKE,QAAQgC,SAAWlC,EAAKI,SAkBxC,MAAO,CACHY,SAAS,EACThB,KAjBgBmC,OAAOC,QAAQL,GAC9BM,IAAI,EAAEnC,EAAQF,MAAI,CACfE,SACAC,SAAUH,EAAKG,SACf+B,QAASlC,EAAKkC,QACdI,SAAWtC,EAAasC,SACxBC,KAAM,KAETC,KAAK,CAACC,EAAGC,IAAMA,EAAER,QAAUO,EAAEP,SAC7BS,MAAM,EAAGnB,GACTa,IAAI,CAACO,EAAOC,KAAA,IACND,EACHL,KAAMM,EAAQ,KAO1B,OAAS1B,GAEL,OADAC,QAAQD,MAAM,yBAA0BA,GACjC,CACHH,SAAS,EACThB,KAAM,GAEd"}