{"version":3,"file":"useBroadcasts-DUfu8DbO.js","sources":["../../src/features/messages/hooks/useMessages.ts","../../src/features/messages/api/message-api.ts","../../src/features/messages/hooks/useBroadcasts.ts","../../src/features/messages/api/broadcast-api.ts"],"sourcesContent":["/**\n * useMessages Hook\n * \n * React hooks for real-time messaging\n */\n\nimport { useState, useEffect } from 'react';\nimport { useMutation, useQuery } from '@tanstack/react-query';\nimport {\n    sendMessage,\n    getHubMessages,\n    subscribeToHubMessages,\n    markMessageAsRead,\n    deleteMessage,\n    type CreateMessageRequest,\n} from '../api/message-api';\nimport { useAuth } from '@/features/auth/hooks/useAuth';\nimport { useHubStore } from '@/lib/store/hub-store';\nimport type { Message } from '@/types';\n\n/**\n * Hook for managing hub messages\n */\nexport const useHubMessages = (hubId: string | undefined) => {\n    const [messages, setMessages] = useState<Message[]>([]);\n\n    // Query for initial load\n    const { isLoading, error } = useQuery({\n        queryKey: ['messages', hubId],\n        queryFn: async () => {\n            if (!hubId) throw new Error('Hub ID is required');\n            const response = await getHubMessages(hubId);\n            if (!response.success) throw new Error(response.error);\n            return response.data || [];\n        },\n        enabled: !!hubId,\n        staleTime: 0, // Always refetch, we use real-time subscription\n    });\n\n    // Subscribe to real-time updates\n    useEffect(() => {\n        if (!hubId) return;\n\n        const unsubscribe = subscribeToHubMessages(\n            hubId,\n            (updatedMessages) => {\n                setMessages(updatedMessages);\n            },\n            (error) => {\n                console.error('Message subscription error:', error);\n            }\n        );\n\n        return unsubscribe;\n    }, [hubId]);\n\n    // Use real-time messages if available, otherwise fallback to query data\n    const finalMessages = messages.length > 0 ? messages : [];\n\n    return {\n        messages: finalMessages,\n        isLoading,\n        error,\n    };\n};\n\n/**\n * Hook for sending messages\n */\nexport const useSendMessage = () => {\n    const { user } = useAuth();\n    const { currentHub } = useHubStore();\n\n    const mutation = useMutation({\n        mutationFn: async (text: string) => {\n            if (!user || !currentHub) {\n                throw new Error('User or hub not available');\n            }\n\n            const request: CreateMessageRequest = {\n                hubId: currentHub.id,\n                senderId: user.id,\n                senderName: user.email?.split('@')[0] || 'User',\n                text: text.trim(),\n                type: 'text',\n            };\n\n            const response = await sendMessage(request);\n            if (!response.success) {\n                throw new Error(response.error);\n            }\n            return response.data!;\n        },\n    });\n\n    return {\n        sendMessage: mutation.mutate,\n        sendMessageAsync: mutation.mutateAsync,\n        isSending: mutation.isPending,\n        error: mutation.error,\n    };\n};\n\n/**\n * Hook for marking messages as read\n */\nexport const useMarkMessageAsRead = () => {\n    const { user } = useAuth();\n    const { currentHub } = useHubStore();\n\n    const mutation = useMutation({\n        mutationFn: async (messageId: string) => {\n            if (!user || !currentHub) {\n                throw new Error('User or hub not available');\n            }\n\n            const response = await markMessageAsRead(\n                currentHub.id,\n                messageId,\n                user.id\n            );\n\n            if (!response.success) {\n                throw new Error(response.error);\n            }\n        },\n    });\n\n    return {\n        markAsRead: mutation.mutate,\n        markAsReadAsync: mutation.mutateAsync,\n        isMarking: mutation.isPending,\n        error: mutation.error,\n    };\n};\n\n/**\n * Hook for deleting messages\n */\nexport const useDeleteMessage = () => {\n    const { user } = useAuth();\n    const { currentHub } = useHubStore();\n\n    const mutation = useMutation({\n        mutationFn: async (messageId: string) => {\n            if (!user || !currentHub) {\n                throw new Error('User or hub not available');\n            }\n\n            const response = await deleteMessage(\n                currentHub.id,\n                messageId,\n                user.id\n            );\n\n            if (!response.success) {\n                throw new Error(response.error);\n            }\n        },\n    });\n\n    return {\n        deleteMessage: mutation.mutate,\n        deleteMessageAsync: mutation.mutateAsync,\n        isDeleting: mutation.isPending,\n        error: mutation.error,\n    };\n};\n","/**\n * Message API\n * \n * Firebase Firestore operations for real-time messaging\n * - Send messages to hub members\n * - Real-time message subscriptions\n * - Mark messages as read\n * - Delete messages\n */\n\nimport {\n    collection,\n    doc,\n    addDoc,\n    getDoc,\n    getDocs,\n    query,\n    orderBy,\n    limit,\n    onSnapshot,\n    serverTimestamp,\n    updateDoc,\n    deleteDoc,\n    Timestamp,\n} from 'firebase/firestore';\nimport { db } from '@/config/firebase';\nimport type { ApiResponse } from '@/types';\nimport type { Message, MessageType } from '@/types';\n\nexport interface CreateMessageRequest {\n    hubId: string;\n    senderId: string;\n    senderName: string;\n    text: string;\n    type?: MessageType;\n    mediaURL?: string;\n}\n\nexport interface MessageDocument extends Omit<Message, 'timestamp'> {\n    timestamp: Timestamp | Date;\n}\n\n/**\n * Send a message to the hub\n */\nexport async function sendMessage(\n    data: CreateMessageRequest\n): Promise<ApiResponse<Message>> {\n    try {\n        const messagesRef = collection(db, 'hubs', data.hubId, 'messages');\n        \n        const messageData = {\n            senderId: data.senderId,\n            senderName: data.senderName,\n            text: data.text,\n            type: data.type || 'text',\n            mediaURL: data.mediaURL || null,\n            readBy: [data.senderId], // Sender has read their own message\n            timestamp: serverTimestamp(),\n        };\n\n        const docRef = await addDoc(messagesRef, messageData);\n        \n        // Fetch the created message to return it\n        const messageSnap = await getDoc(docRef);\n        const messageDataReturned = messageSnap.data();\n        \n        if (!messageDataReturned) {\n            throw new Error('Failed to create message');\n        }\n\n        return {\n            success: true,\n            data: {\n                id: docRef.id,\n                hubId: data.hubId,\n                senderId: data.senderId,\n                senderName: data.senderName,\n                text: data.text,\n                type: data.type || 'text',\n                mediaURL: data.mediaURL,\n                timestamp: messageDataReturned.timestamp?.toDate() || new Date(),\n                readBy: messageDataReturned.readBy || [data.senderId],\n            },\n        };\n    } catch (error) {\n        console.error('Send message error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to send message',\n        };\n    }\n}\n\n/**\n * Get messages for a hub\n */\nexport async function getHubMessages(\n    hubId: string,\n    limitCount: number = 50\n): Promise<ApiResponse<Message[]>> {\n    try {\n        const messagesRef = collection(db, 'hubs', hubId, 'messages');\n        const messagesQuery = query(\n            messagesRef,\n            orderBy('timestamp', 'desc'),\n            limit(limitCount)\n        );\n\n        const snapshot = await getDocs(messagesQuery);\n        const messages: Message[] = [];\n\n        snapshot.forEach((doc) => {\n            const data = doc.data();\n            messages.push({\n                id: doc.id,\n                hubId,\n                senderId: data.senderId,\n                senderName: data.senderName,\n                text: data.text,\n                type: data.type || 'text',\n                mediaURL: data.mediaURL,\n                timestamp: data.timestamp?.toDate() || new Date(),\n                readBy: data.readBy || [],\n            });\n        });\n\n        // Reverse to show oldest first\n        messages.reverse();\n\n        return {\n            success: true,\n            data: messages,\n        };\n    } catch (error) {\n        console.error('Get messages error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to get messages',\n            data: [],\n        };\n    }\n}\n\n/**\n * Subscribe to real-time messages for a hub\n */\nexport function subscribeToHubMessages(\n    hubId: string,\n    onUpdate: (messages: Message[]) => void,\n    onError?: (error: Error) => void,\n    limitCount: number = 50\n): () => void {\n    try {\n        const messagesRef = collection(db, 'hubs', hubId, 'messages');\n        const messagesQuery = query(\n            messagesRef,\n            orderBy('timestamp', 'desc'),\n            limit(limitCount)\n        );\n\n        const unsubscribe = onSnapshot(\n            messagesQuery,\n            (snapshot) => {\n                const messages: Message[] = [];\n\n                snapshot.forEach((doc) => {\n                    const data = doc.data();\n                    messages.push({\n                        id: doc.id,\n                        hubId,\n                        senderId: data.senderId,\n                        senderName: data.senderName,\n                        text: data.text,\n                        type: data.type || 'text',\n                        mediaURL: data.mediaURL,\n                        timestamp: data.timestamp?.toDate() || new Date(),\n                        readBy: data.readBy || [],\n                    });\n                });\n\n                // Reverse to show oldest first (newest at bottom)\n                messages.reverse();\n                onUpdate(messages);\n            },\n            (error) => {\n                console.error('Message subscription error:', error);\n                if (onError) {\n                    onError(error);\n                }\n            }\n        );\n\n        return unsubscribe;\n    } catch (error) {\n        console.error('Failed to subscribe to messages:', error);\n        if (onError) {\n            onError(error instanceof Error ? error : new Error('Unknown error'));\n        }\n        return () => {}; // Return no-op unsubscribe\n    }\n}\n\n/**\n * Mark a message as read\n */\nexport async function markMessageAsRead(\n    hubId: string,\n    messageId: string,\n    userId: string\n): Promise<ApiResponse<void>> {\n    try {\n        const messageRef = doc(db, 'hubs', hubId, 'messages', messageId);\n        const messageSnap = await getDoc(messageRef);\n        \n        if (!messageSnap.exists()) {\n            return {\n                success: false,\n                error: 'Message not found',\n            };\n        }\n\n        const currentReadBy = messageSnap.data()?.readBy || [];\n        \n        // Only update if user hasn't already read it\n        if (!currentReadBy.includes(userId)) {\n            await updateDoc(messageRef, {\n                readBy: [...currentReadBy, userId],\n            });\n        }\n\n        return { success: true };\n    } catch (error) {\n        console.error('Mark message as read error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to mark message as read',\n        };\n    }\n}\n\n/**\n * Delete a message (only by sender or admin)\n */\nexport async function deleteMessage(\n    hubId: string,\n    messageId: string,\n    userId: string\n): Promise<ApiResponse<void>> {\n    try {\n        const messageRef = doc(db, 'hubs', hubId, 'messages', messageId);\n        const messageSnap = await getDoc(messageRef);\n        \n        if (!messageSnap.exists()) {\n            return {\n                success: false,\n                error: 'Message not found',\n            };\n        }\n\n        const messageData = messageSnap.data();\n        \n        // Only allow deletion by sender\n        if (messageData?.senderId !== userId) {\n            return {\n                success: false,\n                error: 'Unauthorized: Only message sender can delete',\n            };\n        }\n\n        await deleteDoc(messageRef);\n\n        return { success: true };\n    } catch (error) {\n        console.error('Delete message error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to delete message',\n        };\n    }\n}\n","import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';\nimport { \n    createBroadcast, \n    getHubBroadcasts, \n    acknowledgeBroadcast,\n    getUnreadBroadcastsCount,\n    type BroadcastPriority,\n    type BroadcastType\n} from '../api/broadcast-api';\nimport { useHubStore } from '@/lib/store/hub-store';\nimport { useAuthStore } from '@/lib/store/auth-store';\nimport toast from 'react-hot-toast';\n\n/**\n * Hook to fetch broadcasts for current hub\n */\nexport const useHubBroadcasts = () => {\n    const { currentHub } = useHubStore();\n\n    return useQuery({\n        queryKey: ['broadcasts', currentHub?.id],\n        queryFn: async () => {\n            if (!currentHub) {\n                return [];\n            }\n            const response = await getHubBroadcasts(currentHub.id);\n            return response.success ? response.data || [] : [];\n        },\n        enabled: !!currentHub,\n        staleTime: 1000 * 30, // 30 seconds\n        refetchInterval: 1000 * 60, // Refetch every minute\n    });\n};\n\n/**\n * Hook to get unread broadcasts count\n */\nexport const useUnreadBroadcastsCount = () => {\n    const { currentHub } = useHubStore();\n    const { user } = useAuthStore();\n\n    return useQuery({\n        queryKey: ['broadcasts', 'unread', currentHub?.id, user?.id],\n        queryFn: async () => {\n            if (!currentHub || !user) {\n                return 0;\n            }\n            const response = await getUnreadBroadcastsCount(currentHub.id, user.id);\n            return response.success ? response.data || 0 : 0;\n        },\n        enabled: !!currentHub && !!user,\n        staleTime: 1000 * 30, // 30 seconds\n        refetchInterval: 1000 * 60, // Refetch every minute\n    });\n};\n\n/**\n * Hook to create a new broadcast\n */\nexport const useCreateBroadcast = () => {\n    const queryClient = useQueryClient();\n    const { currentHub } = useHubStore();\n    const { user } = useAuthStore();\n\n    return useMutation({\n        mutationFn: async (data: {\n            title: string;\n            message: string;\n            priority: BroadcastPriority;\n            type: BroadcastType;\n            expiresAt?: Date;\n        }) => {\n            if (!currentHub || !user) {\n                throw new Error('Hub or user not found');\n            }\n\n            const response = await createBroadcast({\n                hubId: currentHub.id,\n                senderId: user.id,\n                senderName: user.displayName || user.email,\n                ...data,\n            });\n\n            if (!response.success) {\n                throw new Error(response.error);\n            }\n\n            return response.data;\n        },\n        onSuccess: (data) => {\n            // Invalidate broadcasts query\n            queryClient.invalidateQueries({ queryKey: ['broadcasts', currentHub?.id] });\n            queryClient.invalidateQueries({ queryKey: ['broadcasts', 'unread'] });\n\n            // Show success toast based on priority\n            if (data?.priority === 'urgent') {\n                toast.success('ðŸš¨ Emergency alert sent!', {\n                    duration: 5000,\n                });\n            } else {\n                toast.success('Broadcast sent successfully');\n            }\n        },\n        onError: (error: Error) => {\n            console.error('Create broadcast error:', error);\n            toast.error(error.message || 'Failed to send broadcast');\n        },\n    });\n};\n\n/**\n * Hook to acknowledge a broadcast\n */\nexport const useAcknowledgeBroadcast = () => {\n    const queryClient = useQueryClient();\n    const { currentHub } = useHubStore();\n    const { user } = useAuthStore();\n\n    return useMutation({\n        mutationFn: async (broadcastId: string) => {\n            if (!user || !currentHub) {\n                throw new Error('User or hub not found');\n            }\n\n            const response = await acknowledgeBroadcast(currentHub.id, broadcastId, user.id);\n\n            if (!response.success) {\n                throw new Error(response.error);\n            }\n\n            return broadcastId;\n        },\n        onSuccess: () => {\n            // Invalidate queries to update UI\n            queryClient.invalidateQueries({ queryKey: ['broadcasts', currentHub?.id] });\n            queryClient.invalidateQueries({ queryKey: ['broadcasts', 'unread'] });\n        },\n        onError: (error: Error) => {\n            console.error('Acknowledge broadcast error:', error);\n            toast.error('Failed to acknowledge broadcast');\n        },\n    });\n};\n","import { \n    collection, \n    addDoc, \n    query, \n    where, \n    orderBy, \n    getDocs, \n    Timestamp,\n    doc,\n    updateDoc\n} from 'firebase/firestore';\nimport { db } from '@/config/firebase';\nimport type { ApiResponse } from '@/types';\n\nexport type BroadcastPriority = 'low' | 'normal' | 'high' | 'urgent';\nexport type BroadcastType = 'announcement' | 'emergency' | 'reminder' | 'alert';\n\nexport interface BroadcastAlert {\n    id: string;\n    hubId: string;\n    senderId: string;\n    senderName: string;\n    title: string;\n    message: string;\n    priority: BroadcastPriority;\n    type: BroadcastType;\n    timestamp: Date;\n    readBy: string[]; // Array of user IDs who have acknowledged the alert\n    acknowledgedBy?: string[]; // Alias for readBy (for backwards compatibility)\n    expiresAt?: Date; // Optional expiration time\n}\n\ninterface CreateBroadcastData {\n    hubId: string;\n    senderId: string;\n    senderName: string;\n    title: string;\n    message: string;\n    priority: BroadcastPriority;\n    type: BroadcastType;\n    expiresAt?: Date;\n}\n\n/**\n * Create a new broadcast alert\n */\nexport const createBroadcast = async (\n    data: CreateBroadcastData\n): Promise<ApiResponse<BroadcastAlert>> => {\n    try {\n        const broadcastData = {\n            hubId: data.hubId,\n            senderId: data.senderId,\n            senderName: data.senderName,\n            title: data.title,\n            message: data.message,\n            priority: data.priority,\n            type: data.type,\n            timestamp: Timestamp.now(),\n            readBy: [data.senderId], // Sender has read by default\n            expiresAt: data.expiresAt ? Timestamp.fromDate(data.expiresAt) : null,\n        };\n\n        const docRef = await addDoc(\n            collection(db, 'hubs', data.hubId, 'broadcasts'),\n            broadcastData\n        );\n\n        const broadcast: BroadcastAlert = {\n            id: docRef.id,\n            ...data,\n            timestamp: new Date(),\n            readBy: [data.senderId],\n        };\n\n        return {\n            success: true,\n            data: broadcast,\n        };\n    } catch (error) {\n        console.error('Create broadcast error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to create broadcast',\n        };\n    }\n};\n\n/**\n * Get all broadcasts for a hub\n */\nexport const getHubBroadcasts = async (\n    hubId: string,\n    limit: number = 50\n): Promise<ApiResponse<BroadcastAlert[]>> => {\n    try {\n        const now = Timestamp.now();\n        \n        const q = query(\n            collection(db, 'hubs', hubId, 'broadcasts'),\n            orderBy('timestamp', 'desc')\n        );\n\n        const snapshot = await getDocs(q);\n        const broadcasts: BroadcastAlert[] = [];\n\n        snapshot.forEach((doc) => {\n            const data = doc.data();\n            \n            // Skip expired broadcasts\n            if (data.expiresAt && data.expiresAt.toDate() < now.toDate()) {\n                return;\n            }\n\n            broadcasts.push({\n                id: doc.id,\n                hubId: data.hubId,\n                senderId: data.senderId,\n                senderName: data.senderName,\n                title: data.title,\n                message: data.message,\n                priority: data.priority,\n                type: data.type,\n                timestamp: data.timestamp.toDate(),\n                readBy: data.readBy || [],\n                expiresAt: data.expiresAt ? data.expiresAt.toDate() : undefined,\n            });\n        });\n\n        return {\n            success: true,\n            data: broadcasts.slice(0, limit),\n        };\n    } catch (error) {\n        console.error('Get hub broadcasts error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to fetch broadcasts',\n        };\n    }\n};\n\n/**\n * Mark a broadcast as read by a user\n */\nexport const acknowledgeBroadcast = async (\n    hubId: string,\n    broadcastId: string,\n    userId: string\n): Promise<ApiResponse<void>> => {\n    try {\n        const broadcastRef = doc(db, 'hubs', hubId, 'broadcasts', broadcastId);\n        \n        // Get current broadcast to check if user already acknowledged\n        const broadcastSnap = await getDocs(\n            query(\n                collection(db, 'hubs', hubId, 'broadcasts'),\n                where('__name__', '==', broadcastId)\n            )\n        );\n\n        if (broadcastSnap.empty) {\n            return {\n                success: false,\n                error: 'Broadcast not found',\n            };\n        }\n\n        const currentReadBy = broadcastSnap.docs[0].data().readBy || [];\n        \n        if (!currentReadBy.includes(userId)) {\n            await updateDoc(broadcastRef, {\n                readBy: [...currentReadBy, userId],\n            });\n        }\n\n        return {\n            success: true,\n            data: undefined,\n        };\n    } catch (error) {\n        console.error('Acknowledge broadcast error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to acknowledge broadcast',\n        };\n    }\n};\n\n/**\n * Get unread broadcasts count for a user\n */\nexport const getUnreadBroadcastsCount = async (\n    hubId: string,\n    userId: string\n): Promise<ApiResponse<number>> => {\n    try {\n        const q = query(\n            collection(db, 'hubs', hubId, 'broadcasts'),\n            orderBy('timestamp', 'desc')\n        );\n\n        const snapshot = await getDocs(q);\n        let unreadCount = 0;\n        const now = new Date();\n\n        snapshot.forEach((doc) => {\n            const data = doc.data();\n            const readBy = data.readBy || [];\n            const expiresAt = data.expiresAt ? data.expiresAt.toDate() : null;\n\n            // Don't count expired broadcasts\n            if (expiresAt && expiresAt < now) {\n                return;\n            }\n\n            if (!readBy.includes(userId)) {\n                unreadCount++;\n            }\n        });\n\n        return {\n            success: true,\n            data: unreadCount,\n        };\n    } catch (error) {\n        console.error('Get unread broadcasts count error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Failed to get unread count',\n        };\n    }\n};\n"],"names":["useHubMessages","hubId","messages","setMessages","useState","isLoading","error","useQuery","queryKey","queryFn","async","Error","response","limitCount","messagesRef","collection","db","messagesQuery","query","orderBy","limit","snapshot","getDocs","forEach","doc","data","push","id","senderId","senderName","text","type","mediaURL","timestamp","toDate","Date","readBy","reverse","success","console","message","getHubMessages","enabled","staleTime","useEffect","unsubscribe","onUpdate","onError","onSnapshot","subscribeToHubMessages","updatedMessages","length","useSendMessage","user","useAuth","currentHub","useHubStore","mutation","useMutation","mutationFn","request","email","split","trim","messageData","serverTimestamp","docRef","addDoc","messageDataReturned","getDoc","sendMessage","mutate","sendMessageAsync","mutateAsync","isSending","isPending","useMarkMessageAsRead","messageId","userId","messageRef","messageSnap","exists","currentReadBy","includes","updateDoc","markMessageAsRead","markAsRead","markAsReadAsync","isMarking","useDeleteMessage","deleteDoc","deleteMessage","deleteMessageAsync","isDeleting","useHubBroadcasts","now","Timestamp","q","broadcasts","expiresAt","title","priority","slice","getHubBroadcasts","refetchInterval","useCreateBroadcast","queryClient","useQueryClient","useAuthStore","broadcastData","fromDate","createBroadcast","displayName","onSuccess","invalidateQueries","toast","duration","useAcknowledgeBroadcast","broadcastId","broadcastRef","broadcastSnap","where","empty","docs","acknowledgeBroadcast"],"mappings":"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"}